## What is an API?

> An API contract is a promise: â€œIf you send X in this format to this endpoint, you will receive Y or Z error.â€

## What is FastAPI?

> FastAPI is a webframework that helps to build APIs that talk to for frontend apps, mobile apps, or other services

![alt text](API.webp)

## Advantages of FastAPI

> Performance - As fast as Node.js and Go in some cases.

> Autogenerated documentation and test pages using Swagger UI and ReDoc Interfaces for testing APIs.

> Strong data validation with the help of Pydantic.

> FastAPIâ€™s strength lies in declarative, explicit binding of HTTP request data to function parameters.

## Whole Frontend-Backend logic

The website UI is rendered by React running inside the browser.
What interactions do (clicks, form submit, etc.) is decided by frontend logic.

An interaction triggers an API call.
The browser serializes that request into an HTTP-compliant message and sends it to the backend endpoint.
FastAPI receives the HTTP request, parses it, validates the data, and executes backend logic.

FastAPI constructs an HTTP response and sends it back.
The browser receives the HTTP response, gives the data to React, and React updates the UI according to its logic.

User  
â†“  
**React UI** (decides _what_ should happen)  
â†“  
**Browser APIs** (`fetch` / `axios`)  
â†“  
**HTTP request** (serialized)  
â†“  
**FastAPI** (validates & processes)  
â†“  
**HTTP response**  
â†“  
**Browser** (parses HTTP)  
â†“  
**React** (updates state)  
â†“  
**UI changes**

## Pyantic

It not only checks the input data but it parses it and convert it to the right data type. It converts untrusted input to trusted, well-typed python objects.

## Why response model is required?

- When output data is different then the input data. And we need to protect sensitive information from sharing.
- It ensures data of correct type is returned so that the server it is sending its response should not break.
- It automatically create OpenAPI docs

## SQLALCHEMY

> The SQLAlchemy Engine translates SQLAlchemy expressions into database-specific SQL, manages connections using the appropriate DBAPI driver, and executes queries. It handles basic type adaptation, while the ORM layer maps database rows into Python objects.

```
SQLAlchemy ORM (Session)
   â†“  (object mapping)
SQLAlchemy Core
   â†“  (SQL expression)
ENGINE
   â†“  (dialect + DBAPI)
Database
```

> DBAPI for Postgres: psycopg2, >MySQL: mysqlclient

## Database and FastAPI flow:

```
FastAPI creates a Session.
ORM mapping defines how Python classes map to DB tables.
db.query(User) is an ORM expression.
ORM builds SQL and gives it to the Session.
Session uses Engine to get a connection and execute SQL.
Results return â†’ ORM maps rows â†’ Python objects.
Session tracks object changes.
```

## Use of yield in database (sqlalchemy)

FastAPI advances the generator once to get the dependency value, pauses at yield, runs the endpoint, then advances the generator again to execute cleanup code.

## What is a Session?

Session is a temporary Python-side representation of a transaction, not the database itself.

Correct mental analogy (best one)
ğŸªŸ Session = Window
ğŸ¢ Database = Building

Window lets you see inside

Window lets you send instructions

Window does not contain the building

Closing the window doesnâ€™t destroy the building.

**What actually happens?**
Session fetched data â†’ stored in Python

You modified Python object

Session remembers the change

Database is untouched (until flush/commit)

## Path Parameters

Path parameters are **required values** that are part of the URL path.  
They are used to identify a **specific resource**.

### Key Points

- Declared inside `{}` in the route
- Always required
- Automatically validated and type-cast by FastAPI
- Commonly used for resource identifiers (id, slug)

### Example

```python
@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}
```

Request:

```
GET /users/5
```

If `user_id` is not an integer â†’ FastAPI returns `422 Unprocessable Entity`.

---

## Query Parameters

Query parameters are **optional or required parameters** passed after `?` in the URL.
They are commonly used for **filtering, pagination, sorting**.

### Key Points

- Declared as function parameters
- Become query parameters when not part of the path
- Optional if they have default values
- Validated and type-cast automatically

### Example

```python
@app.get("/items/")
def read_items(skip: int = 0, limit: int = 10):
    return {"skip": skip, "limit": limit}
```

Request:

```
GET /items/?skip=5&limit=20
```

Required query parameter:

```python
@app.get("/search/")
def search(q: str):
    return {"query": q}
```

Request:

```
GET /search/?q=fastapi
```

---

## Path vs Query Parameters

| Feature      | Path Parameter    | Query Parameter          |
| ------------ | ----------------- | ------------------------ |
| Required     | Yes               | Optional by default      |
| URL position | Part of path      | After `?`                |
| Use case     | Identify resource | Filter / modify response |

---

## Response Model

`response_model` defines the **shape of the response** sent back to the client.
It acts as a **data exposure contract**.

### Why Response Model Is Needed

- Prevents data leaks (e.g., passwords)
- Filters extra fields
- Validates output data
- Improves OpenAPI documentation

---

## Response Model Example

### Pydantic Schema

```python
from pydantic import BaseModel

class UserResponse(BaseModel):
    id: int
    name: str
    email: str

    class Config:
        from_attributes = True  # Pydantic v2
```

### Endpoint

```python
@app.get("/users/{user_id}", response_model=UserResponse)
def get_user(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).first()
    return user
```

Even if `user` contains extra fields like `password`, they will not be returned.

---

## Response Model Behavior

- Extra fields are silently dropped
- Missing required fields raise validation errors
- ORM objects are automatically converted to dict

---

## Common Mistakes

- Returning ORM objects without `response_model`
- Using DB models as response schemas
- Assuming response model is optional for security

## PUT vs PATCH

PUT vs PATCH

PUT â†’ replace entire resource

PATCH â†’ update partial fields

**Idempotency (Key Idea)**

> An operation is idempotent if repeating it produces the same final state.

**Optional[str]**

- Optional[str] = None means â€œthis field is not required, but if provided, it must be a string.â€

- Optional[str] means the field may be missing or may be None; it does not mean â€œuse None instead of the value.â€

**What happens if client sends partial data with PUT?**

> PUT is meant to replace the entire resource. Sending partial data can result in missing fields being overwritten or cleared.

**What fields could accidentally be wiped?**

> Any fields not included in the PUT request payload.

## Authorization vs Authentication

> Authentication - Giving the proof of your identity
> Authorization - What are you allowed to do?

## JWT

> JWT = Json Web Token

- A signed proof of identity that the backend can verify you without storing sessions.

## What is a Session

> A session is an ongoing interaction between a client and a server.

## Stateful vs Stateless

- State = memory of the past.
- Session state = what the server remembers about you between requests.

Session is stateful because it stores:

- Who the user is
- Whether they are logged in
- What permissions they have
- Temporary data (cart, preferences, CSRF tokens)

For JWT:

The server only:

- verifies the token signature
- reads data inside the token

Thatâ€™s it. JWT is like an ID card that contains your name, role, and an expiry date.
The security guard does not remember who entered or track visits; it simply checks the ID cardâ€™s authenticity and validity each time and allows entry.

> On each request, the same JWT is sent by the client. Each request usually corresponds to a user action, and the server checks whether the token is still valid by reading its expiry time.

## Alembic - Version control for a Database - Keeps Tack of Updates

`alembic upgrade head`

- This command make the pending migrations in the head i.e. database

`alembic revision --autogenerate -m "message"`

- This command compares the current SQLAlchemy models wuth the current database schema and generates a migration file describing the difference.

## Never blindly run Alembic migrations â€” always read and understand the generated migration file before applying it.

## Authentication and Authorization - Questions

**Why start with roles instead of permissions?**

> Roles provide coarse-grained access control and are easier to reason about early in a systemâ€™s design. Permissions are fine-grained and usually assigned to roles rather than individual users. Starting with roles simplifies authorization logic and allows the system to evolve toward permissions later without premature complexity.

**How do you enforce ownership?**

> Ownership is enforced by validating that the authenticated user (resolved via dependencies) is the owner of the requested resource before executing the endpoint logic.

**What happens if authorization logic is scattered everywhere?**

> Scattered authorization logic leads to inconsistent security checks, duplicated database queries, harder maintenance, and a higher risk of authorization bugs. Centralizing authorization improves correctness, performance, and long-term maintainability.

**Why return 403 instead of 401?**

> `401 Unauthorized` is returned when the user is not authenticated (missing or invalid credentials).

> `403 Forbidden` is returned when the user is authenticated but does not have permission to access the resource.

In role-based authorization failures, 403 is the correct response.

## Background tasks

> the tasks that run after api has responded but it is part of the same process.

**What if email sending fails?**

> Email sending should be treated as a non-critical side effect. If it fails, the system should retry asynchronously using a background job or queue, without blocking or failing the user creation flow.

**Should user creation fail?**

> User creation should fail only for critical errors such as validation failures or integrity constraints (e.g., duplicate email). Transient failures like email delivery issues should not block user creation.

**Where would you log the error?**

> Errors should be logged on the backend with sufficient context, such as user ID, request ID, and error type, using a centralized logging system to enable debugging and monitoring.

**Should you retry?**

> Retries should be applied only for transient failures and implemented with limits and exponential backoff to avoid overwhelming downstream systems. Permanent failures should be logged and surfaced for manual intervention.

```
Latency is request-level concern
Reliability is system level concern
```

> Background affects system reliability. A system is reliable when it does what it has promised.

Example - sending email, generating invoice are examples of backgroud tasks. If they are not completed then it may cause increased number of suppor tickets and affect reliability of the system.

**Other Issues**

Silent data loss
â†’ â€œData that should exist never gets saved, and nobody notices.â€

Unprocessed events
â†’ â€œSomething happened, but the follow-up work never ran.â€

Operational backlog
â†’ â€œFailed work keeps piling up until humans must clean it.â€

Degraded downstream services
â†’ â€œOther systems work with missing or delayed data.â€

ğŸ‘‰ Upstream

The system that sends data or requests to you

ğŸ‘‰ Downstream

The system that receives data or requests from you
